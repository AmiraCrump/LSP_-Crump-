Amira Crump 
Professor Woolfolk
Large Scale Programming 
22 April 2022
Final Examination

Creational 
The Builder pattern is a creational design pattern that aims to separate the construction of complex objects in a step-by-step format. The design pattern lets you construct different types of an object while using the same construction code. Therefore, the process of constructing an object should be pretty basic so that it may be used to create different representations of the same object. The builder design pattern is usually put into use when an object can be created with a lot of parameters. For example, let’s consider a class used to create cookies. You would need various ingredients like eggs, milk, flour, sugar, and butter. You would then have to take into consideration optional ingredients like nuts, chocolate chips, etc. to create different types of cookies. The problem here is we now have a variety of different constructors that will accept various different parameters. Now, you could partially solve this by creating a giant constructor in the base of cookies that includes all possible parameters, or ingredients, that control the cookie object. The problem with this is most of the parameters would go unused, creating an extremely complex and messy constructor call where most of the parameters used render themselves useless. The Builder pattern offers solutions to both of these problems. The Builder design pattern suggests that you extract the object construction code and move it to separate objects called builders. The pattern organizes object construction into a set of steps, ie (add sugar, add chocolate chips, etc.) Therefore, to bake cookies you would only have to execute a series of steps on a builder object. The advantages to using the Builder design pattern are, reduced and highly readable parameters, no need to pass in null for optional parameters, and the object is always in a complete state. Although, some disadvantages include an increase in the number of lines of code and creating a ConcreteBuilder for each type of product. 

The Prototype design pattern is a creational design pattern that allows you to create a duplicate of existing objects without your code depending on their classes. Normally if you needed to create an exact copy of an object, you would have to create a new object of the same class and then copy over all existing values of the original object. Though all objects cannot be copied this way due to private fields that are not visible from the outside of the object. Another problem with this approach is the reliance on the original object’s class. The Prototype pattern offers a solution to these problems. The pattern provides a common interface for all objects that can be cloned. This interface allows you to clone an object without tethering your code to the class of the original object. Basically, when you need a copy of an object you’ve already configured, you would just clone a prototype instead of meticulously creating a new object from scratch. The Prototype design pattern offers a variety of advantages, some being: cloning objects without dependency on their concrete classes, getting rid of repeated initialization code and replacing it with pre-built cloning prototypes, accelerating the production of complex objects, and getting an alternative to inheritance when dealing with configuration presets for complex objects. On the other hand, the main disadvantage of using the Prototype design pattern is difficulty cloning complex objects that have circular references.  

Structural
The bridge design pattern allows the splitting and organization of a large class or set of closely related classes while progressively adding functionality. They are divided into two hierarchies, abstraction and implementation, which are developed independently. The two hierarchies utilize one another allowing abstraction to receive a reference to an object of implementation. There are four different elements within the Bridge design pattern. These patterns include abstraction, refined abstraction, implementer, and concrete implementation. This pattern involves an interface that acts as a bridge which makes the functionality of concrete classes independent from interface implementer classes. When using the Bridge design pattern there are several different ways to apply it. It can be applied when there is a need for an extension of a class in various independent dimensions, switch implementations at runtime, and divide and organize a monolithic class with multiple variants of some functionality. Although there are numerous problems that can be solved with bridge design patterns, however, one specific problem that can be brought to light is extending a class into two independent dimensions which often occurs with class inheritance. This problem can be solved by switching from inheritance to object composition. For example, if there were a class, vehicles, with subclasses, cars, and motorcycles, and there was a desire to extend this class hierarchy to incorporate the colors black and silver; you would need to create four class combinations such as BlackCar and SilverMotorcycle. To solve this problem the Bridge pattern is used to extract one of the dimensions into a separate class hierarchy. Following this approach, we will create color relationships with two subclasses black and silver. The Vehicle class is able to delegate any color-related work to the linked color object. There will be a bridge between the Vehicle and Color classes. There will be no need for changing any hierarchy due to the Bridge design pattern.

The Adapter design pattern allows incompatible classes to interact with each other by converting the interface of one class into an interface expected by the clients and is meant to solve a real-time design problem. The Adapter class is used when a class needs to be reused, and when several existing subclasses want to be reused. The main advantage of the Adapter design is that you are able to separate the interface or data from the primary business logic. The main disadvantage of the Adapter design is that the overall complexity increases. The Adapter design can solve a multitude of problems, but the ability to use two completely different interfaces and allow them to connect. For example, if you come across a situation where you have a three-prong plug but there is only a two-prong plug outlet, the adapter would convert the three-prong plug that you have into a two-prong plug so that it is compatible. To use the Adapter design pattern there is a client which makes a request to the adapter, then the adapter would translate the request made using the interface, once the request is translated, the client receives the result of the call without realizing the adapter's presence.


Behavioral
	Command is a behavioral design pattern that turns requests into stand-alone objects that contain all the information about the said request. This design allows the pass of requests as method arguments, delays or queue the request's execution, and support otherwise undoable operations. An example would be if you were creating a menu bar with buttons (class) that execute different tasks. The simplest way to do this would be to create a bunch of subclasses for each area the button is used. These subclasses contain the code to execute the action once the button is clicked. Though using this method, you would have way too many subclasses that would risk breaking the code each time it is modified to create a new button. This is where the use of a graphical user interface (GUI) comes into play. The Command pattern design suggests that GUI objects shouldn’t send requests directly. Instead, you would extract all the details from the request and put them into a separate command class that triggers this request. Command objects serve as a link between GUI and business logic objects. Therefore, the business object no longer has to know what business logic object will receive the request and how it’ll be processed. Instead, the GUI object triggers the command and handles all the minute details. The advantages of using the Command behavioral design are the single responsibility principle, open/closed principle, you can now implement undo and redo, you can now use deferred execution of operations, and you can now combine a set of simple commands into a singular complex one. The main disadvantage of using the Command behavioral design is that the code will become a bit more complicated due to the introduction of a new layer of graphical design interface between the senders and receivers in the code.

The Observer behavioral design pattern allows you to define a subscription mechanism to let multiple objects know about events that happen to the object they are observing. For example, let's pretend we have two types of objects, person and mailbox. The person is waiting for their package to arrive and checks the mailbox daily to see if it has been delivered. Though, most of these trips to the mailbox would be pointless because the package would not be there. On the other hand, the full signal on the mailbox would notify the person every single time any piece of mail gets delivered. This would save useless trips to the mailbox but it would not tell you when your package would arrive. For the sake of this example, we are going to call the object of interest (mailbox) the publisher, and all other objects who want to track the publisher are called the (person) subscribers. The observer pattern design suggests the addition of a subscription mechanism. Now, whenever something notable happens to the publisher, ie. the package arrives, the code goes over its subscribers and calls the specific notification method. Some advantages of using the Observer behavioral design include the open/closed principle where you can introduce new subscriber classes without having to change the entire publisher's code and you would now be able to establish relationships between objects at runtime. The main disadvantage to using the Observer behavioral design method would be that there is not rhyme or rhythm to the way subscribers are notified, the order would be completely random. 


The difference between design pattern reuse and code reuse is that the external components of a structure would be considered a design pattern and the ability to use the same design for different structures would be design pattern reuse. Whereas when there would be the same design patterns, there could be many different internal components, which would describe code reuse. 

References 
https://refactoring.guru/design-patterns 

https://www.geeksforgeeks.org/builder-design-pattern/ 

https://refactoring.guru/design-patterns/adapter

https://www.geeksforgeeks.org/adapter-pattern/

http://www.cs.fsu.edu/~myers/cop3331/notes/patterns1.html
